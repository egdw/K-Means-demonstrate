# -*- coding: utf-8 -*-
"""k-means实现图片降维.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Iuz4_cu1MnikBuiUCHJP5SgVzIFj_rgN
"""

import numpy as np
import matplotlib.pyplot as plt
import math
from skimage import io

centers_num = int(input("请输入K值:"))

image_url = input("请输入图片的地址:")


# 读取数据
image = io.imread(image_url)
io.imshow(image)
io.show()

# 获取行和列
rows = image.shape[0]
cols = image.shape[1]
print(rows,cols)
# 数据进行reshape
reshape_image = image.reshape(rows*cols,3)
x = reshape_image
# 创建起始的质心
centers = []
l = int(len(x)/centers_num)
for center_index in range(centers_num):
  # 根据用户输入的数据随机选择三个质心
  # 我这里通过除法直接计算出随机数据
  # 150 / 3 = 50
  # 0 50 100
  centers.append(x[(center_index)*l])

# 因为是三维的数据，所以这里的欧式公式需要修改成三维空间
# 计算欧式距离
def euclid_distance(point_one,point_two):
  return math.sqrt(math.pow(point_one[0] - point_two[0],2) + math.pow(point_one[1] - point_two[1],2) + math.pow(point_one[2] - point_two[2],2))

# 计算传入的列表中最小值的索引
def get_min_index_of_list(min_list):
  # print(min_list)
  min = 0
  for i in range(len(min_list)):
    if min_list[i]<min_list[min]:
      min = i
  return min

# 计算点到质心的距离。
# centers代表质心 points代表点
def calc_distance(centers,points):
  # 通过欧式距离计算两个点之间的距离
  global centers_num
  distances = []
  # 创建好列表，存放数据
  indexs = []
  for center in range(centers_num):
    distance = []
    index = []
    distances.append(distance)
    indexs.append(index)
    
 # 计算各个点的欧式距离
  for index,point in enumerate(points):
    min_list = []
    for center in range(centers_num):
      min_list.append(euclid_distance(point,centers[center]))
    min_index = get_min_index_of_list(min_list)  
    distances[min_index].append(point)
    indexs[min_index].append(index)

  return distances,indexs

def calc_xyz_avg(xyzs):
  l = []
  for i in range(len(xyzs)):
    x_sum = 0
    y_sum = 0
    z_sum = 0
    for j in xyzs[i]:
      x_sum = x_sum + j[0]
      y_sum = y_sum + j[1]
      z_sum = z_sum + j[2]
    x_sum = x_sum / len(xyzs[i])
    y_sum = y_sum / len(xyzs[i])
    z_sum = z_sum / len(xyzs[i])
    l.append((x_sum,y_sum,z_sum))
  return l

calc_xyz_avg(calc_distance(centers,x)) # 测试计算avg是否可行


# 一行显示五个
row_size = 10
col_size = 5

iterate_index = 1

# 从下面开始执行循环，知道小于一个阈值
flag = True
temp_index = 1
while flag:
  cd,indexs = calc_distance(centers,x)
  # 计算出新的平均数
  cxa = calc_xyz_avg(cd)
  correct_num = 0
  print("epoch:%s\n"%(temp_index))
  temp_index = temp_index + 1
  # 计算原始centers和cxa之间的距离，如果小于某一个值就认为结束了。
  for i in range(len(centers)):
    if euclid_distance(centers[i],cxa[i]) < 1:
      correct_num = correct_num + 1
  if correct_num == len(centers):
    flag = False
  else:
    centers = cxa
  
# 代表当前的族群
group = cd
group_indexs = indexs
print("完成！")

# 对所有相近的像素都对center的像素值进行替换
# 这里需要注意的是，类型需要转换成为int
for index,center in enumerate(np.array(centers,dtype=int)):
  # print(center)
  for i in indexs[index]:
    x[i] = center

# 重新转换成原先图片的shape，然后进行显示
origin_x = x.reshape(rows,cols,3)

io.imshow(origin_x)
io.show()

