# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12tD9IQ9Ezw2UMen4iocttd--cSR_IdlA
"""

from sklearn.datasets import make_blobs
import numpy as np
import matplotlib.pyplot as plt
import math


n_samples_num = 1500



centers_num = int(input("请输入你要分类的个数:"))

x, y = make_blobs(n_samples=n_samples_num, n_features=2, centers=centers_num, cluster_std=0.5, shuffle=True, random_state=23)

plt.scatter(x[:, 0], x[:, 1], c='red', marker='o', s=50,label='point')
plt.grid()
plt.legend()
plt.show()

# 创建起始的质心
centers = []
l = int(len(x)/centers_num)
for center_index in range(centers_num):
  # 根据用户输入的数据随机选择三个质心
  # 我这里通过除法直接计算出随机数据
  # 150 / 3 = 50
  # 0 50 100
  centers.append(x[(center_index)*l])

centers # 此即为选择的质心

# 计算欧式距离
def euclid_distance(point_one,point_two):
  return math.sqrt(math.pow(point_one[0] - point_two[0],2) + math.pow(point_one[1] - point_two[1],2))

# 计算传入的列表中最小值的索引
def get_min_index_of_list(min_list):
  # print(min_list)
  min = 0
  for i in range(len(min_list)):
    if min_list[i]<min_list[min]:
      min = i
  return min

# 计算点到质心的距离。
# centers代表质心 points代表点
def calc_distance(centers,points):
  # 通过欧式距离计算两个点之间的距离
  global centers_num
  distances = []
  # 创建好列表，存放数据
  for center in range(centers_num):
    distance = []
    distances.append(distance)
    
 # 计算各个点的欧式距离
  for point in points:
    min_list = []
    for center in range(centers_num):
      min_list.append(euclid_distance(point,centers[center]))
    distances[get_min_index_of_list(min_list)].append(point)

  return distances

def calc_xy_avg(xys):
  l = []
  for i in range(len(xys)):
    x_sum = 0
    y_sum = 0
    for j in xys[i]:
      x_sum = x_sum + j[0]
      y_sum = y_sum + j[1]
    x_sum = x_sum / len(xys[i])
    y_sum = y_sum / len(xys[i])
    l.append((x_sum,y_sum))
  return l

calc_xy_avg(calc_distance(centers,x))

colors = ['red','blue','yellow','purple','pink','brown','tan','orange','grey','olive','black','lime','navy','indigo','wheat','cyan','linen','maroon','snow','moccasin','slateblue','thistle','plum','drakcyan','honeydew']

# 一行显示五个
row_size = 10
col_size = 5

iterate_index = 1

# 从下面开始执行循环，知道小于一个阈值
flag = True
plt.figure(figsize=(100,150))
while flag:
  # global centers
  cd = calc_distance(centers,x)
  # 计算出新的平均数
  cxa = calc_xy_avg(cd)
  correct_num = 0


  #过程可视化代码
  plt.subplot(row_size,col_size,iterate_index)
  iterate_index = iterate_index + 1
  for i in range(len(cd)):
    arr = np.array(cd[i])
    plt.scatter(arr[:, 0], arr[:, 1], c=colors[i], marker='o', s=50,label=str(i))
    # plt.legend(fontsize=40,title_fontsize=40)
    plt.title('step:%s'%(iterate_index-1),fontdict={'weight':'normal','size': 44})
  #过程可视化代码

  # 计算原始centers和cxa之间的距离，如果小于某一个值就认为结束了。
  for i in range(len(centers)):
    if euclid_distance(centers[i],cxa[i]) < 0.01:
      correct_num = correct_num + 1
  if correct_num == len(centers):
    flag = False
  else:
    centers = cxa

# 代表当前的族群
group = cd
print("完成！")
# print(centers)
# print(group)
# plt.legend(fontsize=40,title_fontsize=40)
plt.savefig('/Users/hdy/Downloads/result.jpg')
# plt.show()
# plt.plot()
# plt.subplot(10,10,1)

# 单独的结果输出
plt.figure(figsize=(10,10))
colors = ['red','blue','yellow','purple','pink','brown','tan','orange','grey','olive','black','lime','navy','indigo','wheat','cyan','linen','maroon','snow','moccasin','slateblue','thistle','plum','drakcyan','honeydew']
for i in range(len(group)):
  arr = np.array(group[i])
  plt.scatter(arr[:, 0], arr[:, 1], c=colors[i], marker='o', s=50,label=str(i))
plt.legend()
plt.show()

